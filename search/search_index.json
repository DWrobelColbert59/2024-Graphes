{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Les graphes","text":""},{"location":"#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":"<p>De mani\u00e8re g\u00e9n\u00e9rale, un graphe permet de repr\u00e9senter les connexions d\u2019un ensemble en exprimant les relations entre ses \u00e9l\u00e9ments : r\u00e9seau de communication, r\u00e9seau routier, circuit \u00e9lectronique, ... , mais aussi relations sociales ou interactions entre esp\u00e8ces animales.</p> <p>Les ponts de K\u00f6nigsberg</p> <p>Le probl\u00e8me des sept ponts de K\u00f6nigsberg cherche \u00e0 d\u00e9terminer s'il existe un chemin permettant de revenir \u00e0 son point de d\u00e9part en empruntant une seule fois chaque pont de la ville. Leonhard Euler d\u00e9montre en 1735 qu'un tel chemin n'existe pas.</p> <p> </p> <p>La th\u00e9orie des graphes est avant tout une branche \u00e0 part enti\u00e8re et d\u00e9j\u00e0 ancienne des math\u00e9matiques.  N\u00e9anmoins, l\u2019importance accrue que rev\u00eat l\u2019aspect algorithmique dans ses applications pratiques en fait aussi un domaine incontournable de l\u2019informatique.  Pour sch\u00e9matiser, les math\u00e9maticiens s\u2019int\u00e9ressent avant tout aux propri\u00e9t\u00e9s globales des graphes l\u00e0 o\u00f9 les informaticiens vont plut\u00f4t chercher \u00e0 concevoir des algorithmes efficaces pour r\u00e9soudre un probl\u00e8me faisant intervenir un graphe.</p>"},{"location":"#les-graphes-simples","title":"Les graphes simples","text":"<p>D\u00e9finition</p> <p>En math\u00e9matiques, un graphe est un couple \\(G = (V, E)\\) avec :</p> <ul> <li> <p>\\(V\\) l'ensemble des sommets du graphe ;</p> </li> <li> <p>\\(E\\) l'ensemble des ar\u00eates, chacune \u00e9tant associ\u00e9e \u00e0 un couple \\(\\lbrace u, v \\rbrace\\) avec \\(u, v \\in E\\).</p> </li> </ul> <p>Le nombre de sommets dans un graphe correspond \u00e0 son ordre.</p> Pourquoi des accolades pour une ar\u00eate ? <p>Pour d\u00e9crire l'ar\u00eate entre les sommets \\(u\\) et \\(v\\), on utilise la notation \\(\\lbrace u, v\\rbrace\\) pour mettre en avant le fait que l'ar\u00eate ne soit pas orient\u00e9e.</p> <p>Vocabulaire</p> <p>S'il existe une ar\u00eate entre deux sommets \\(u\\) et \\(v\\), on dit que ces sommets sont adjacents.</p> <p>Exemple de graphe</p> <p>Math\u00e9matiquement, le graphe suivant :</p> <p> </p> <p>s'\u00e9crit \\(G = (V, E)\\) avec :</p> \\[     V = \\lbrace A, B, C, D, E, F, G\\rbrace \\quad \\textrm{et} \\quad E = \\left\\lbrace \\rule[0.5cm]{0cm}{0pt} \\lbrace A, B \\rbrace, \\lbrace A, C\\rbrace, \\lbrace A, D\\rbrace, \\lbrace B, D \\rbrace, \\lbrace B, E\\rbrace, \\lbrace B, G\\rbrace, \\lbrace C, E\\rbrace, \\lbrace C,F \\rbrace \\right\\rbrace \\] <p>Cha\u00eene</p> <p>Dans un graphe \\(G = (V, E)\\), une cha\u00eene reliant \\(u \\in V\\) \u00e0 \\(v \\in V\\) est d\u00e9finie par une suite finie d'ar\u00eates cons\u00e9cutives reliant \\(u\\) \u00e0 \\(v\\). S'il existe un chemin allant de \\(u \\in V\\) \u00e0 \\(u\\) on dit que c'est un cycle.</p> <p>Degr\u00e9 d'un sommet</p> <p>Soit \\(G = (V, E)\\) un graphe et \\(v \\in V\\) un sommet. On note \\(\\delta(v)\\) le nombre de voisins de \\(v\\). Ce nombre est aussi appel\u00e9 le degr\u00e9 de \\(v\\).</p> <p>Exemple</p> <p>Dans le graphe pr\u00e9c\u00e9dent, on a \\(\\delta(B) = 4\\).</p>"},{"location":"#les-graphes-orientes","title":"Les graphes orient\u00e9s","text":"<p>D\u00e9finition</p> <p>On dit qu'un graphe est orient\u00e9 lorsque les ar\u00eates poss\u00e8dent un sens. L'ar\u00eate \\(\\lbrace u, v \\rbrace\\) est alors not\u00e9e \\((u, v)\\) et est appel\u00e9e un arc.</p> <p>Pour un arc \\((u, v)\\) donn\u00e9 :</p> <ul> <li>le sommet \\(u\\) est appel\u00e9 l'origine ;</li> <li>le sommet \\(v\\) est appel\u00e9 la cible.</li> </ul> Attention ! <p>Attention au changement de notation et de noms ! </p> <p>L'ar\u00eate \\(\\lbrace u, v\\rbrace\\) laisse place \u00e0 l'arc \\((u, v)\\). De la m\u00eame fa\u00e7on, on ne parle plus de cha\u00eenes mais de chemins.</p> <p>Exemple de graphe orient\u00e9</p> <p>Math\u00e9matiquement, le graphe orient\u00e9 suivant :</p> <p> </p> <p>s'\u00e9crit \\(G = (V, E)\\) avec :</p> \\[     V = \\lbrace A, B, C, D, E, F, G\\rbrace \\quad \\textrm{et} \\quad E = \\left\\lbrace \\rule[0.5cm]{0cm}{0pt} (A, C), (A, F), (B, A), (B, G), (C, D), (D, B), (D, E)\\right\\rbrace \\] <p>Degr\u00e9 entrant et sortant</p> <p>Dans un graphe orient\u00e9, on distingue la notion de degr\u00e9 entrant not\u00e9 \\(\\delta^-\\) de celle de degr\u00e9 sortant not\u00e9 \\(\\delta^+\\).</p> <p>Exemple</p> <p>Dans le graphe pr\u00e9c\u00e9dent, on a \\(\\delta^-(D) = 1\\) et \\(\\delta^+(D) = 3\\).</p>"},{"location":"#les-graphes-ponderes","title":"Les graphes pond\u00e9r\u00e9s","text":"<p>D\u00e9finition</p> <p>On dit qu'un graphe \\(G = (V, E)\\) est pond\u00e9r\u00e9 si chaque ar\u00eate (ou chaque arc) est associ\u00e9 \u00e0 un nombre. Ce nombre est alors appel\u00e9 le poids.</p> <p>Exemple de graphe pond\u00e9r\u00e9</p> <p>Par exemple, le graphe suivant est pond\u00e9r\u00e9.</p> <p> </p> Attention <p>On peut pond\u00e9rer un graphe simple mais aussi un graphe orient\u00e9.</p>"},{"location":"#implantation","title":"Implantation","text":"<p>On s'int\u00e9resse ici \u00e0 la fa\u00e7on dont on implante un graphe en Python.</p>"},{"location":"#liste-dadjacence","title":"Liste d'adjacence","text":"<p>D\u00e9finition</p> <p>On consid\u00e8re un graphe \\(G = (V, E)\\) \u00e0 \\(n\\) sommets.  </p> <p>On appelle liste d'adjacence de \\(G\\), un tableau de taille \\(n\\) o\u00f9 le \\(i\\)-i\u00e8me \u00e9l\u00e9ment correspond \u00e0 la liste des voisins du sommet num\u00e9ro \\(i\\).</p> <p>Exemple</p> <p>Dans le graphe </p> <p> </p> <p>la liste d'adjacence se repr\u00e9sente par :</p> \\[     \\begin{array}{ccl}         \\begin{array}{|c|}\\hline A\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|}\\hline C &amp; E \\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline B\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|}\\hline G \\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline C\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|c|c|}\\hline A &amp; D &amp; F &amp; G \\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline D\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|c|}\\hline C &amp; E &amp; F\\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline E\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|}\\hline A &amp; D \\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline F\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|c|}\\hline C &amp; D &amp; G\\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline G\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|c|}\\hline B &amp; C &amp; F\\\\\\hline\\end{array}\\\\     \\end{array} \\] <p>Avantages</p> <p>Si le graphe poss\u00e8de peu d'ar\u00eates, cette repr\u00e9sentation occupe peu de place en m\u00e9moire.</p> <p>En python, on pr\u00e9conise l'utilisation de dictionnaire pour mod\u00e9liser un graphe par sa liste d'adjacence. On fait \u00e9voluer la structure de donn\u00e9es suivant que le graphe est pond\u00e9r\u00e9 ou non.</p> <p>Utilisation d'un dictionnaire</p> Graphe simpleGraphe orient\u00e9Graphe pond\u00e9r\u00e9 <p> </p> <p>En python, la liste d'adjacence pourrait s'\u00e9crire </p> Liste d'adjacence<pre><code>G = {   'A' : ['E', 'F'],\n        'B' : ['E'],\n        'C' : ['F'],\n        'D' : ['G'],\n        'E' : ['A', 'B', 'F'],\n        'F' : ['A', 'C', 'E', 'G'],\n        'G' : ['D', 'F']}\n</code></pre> <p> </p> <p>En python, la liste d'adjacence pourrait s'\u00e9crire </p> Liste d'adjacence<pre><code>G = {   'A' : ['F'],\n        'B' : [],\n        'C' : ['F'],\n        'D' : [],\n        'E' : ['A', 'B'],\n        'F' : ['E', 'G'],\n        'G' : ['D']}\n</code></pre> <p> </p> <p>En python, la liste d'adjacence pourrait s'\u00e9crire </p> Liste d'adjacence<pre><code>G = {   'A' : [('E', 1), ('F', 5)],\n        'B' : [('E', 8)],\n        'C' : [('F', 3)],\n        'D' : [('G', 9)],\n        'E' : [('A', 1), ('B', 8), ('F', 4)],\n        'F' : [('A', 5), ('C', 3), ('E', 4), ('G', 6)],\n        'G' : [('D', 9), ('F', 6)]}\n</code></pre>"},{"location":"#matrice-dadjacence","title":"Matrice d'adjacence","text":"<p>Il existe diff\u00e9rentes matrices que l'on peut associer \u00e0 un graphe \\(G\\).</p> <p>D\u00e9finition</p> <p>Soit \\(G = (V, E)\\) un graphe o\u00f9 l'on note \\(S_1, S_2, \\cdots, S_n\\) les diff\u00e9rents sommets. On appelle matrice d'adjacence de \\(G\\) le tableau de taille \\(n\\times n\\) o\u00f9 le coefficient  de la ligne \\(i\\) et de la colonne \\(j\\) est donn\u00e9 par :</p> \\[     a_{i, j} = \\left\\lbrace \\begin{array}{ll}1 &amp; \\textrm{si }S_i \\textrm{ et } S_j \\textrm{ sont adjacents}\\\\ 0 &amp; \\textrm{sinon}\\end{array}\\right. \\] <p>Attention</p> <p>Dans le cas d'un graphe orient\u00e9, le coefficient \\(a_{i, j}\\) vaut \\(1\\) seulement s'il existe un arc entre le sommet \\(S_i\\) et le sommet \\(S_j\\).</p> <p>Exemples</p> Graphe simpleGraphe orient\u00e9 <p> </p> <p>La matrice d'adjacence associ\u00e9 \u00e0 ce graphe est :</p> \\[     \\left(\\begin{matrix}         0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\\\         1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\         1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\\\         0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0     \\end{matrix}\\right)     \\] <p> </p> <p>La matrice d'adjacence associ\u00e9 \u00e0 ce graphe est :</p> \\[     \\left(\\begin{matrix}         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\         1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\\\         0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0     \\end{matrix}\\right)     \\] <p>En python, on peut implanter une matrice d'adjacence avec une liste de liste.</p> <p>Exemple</p> <p>La matrice \\(\\left(\\begin{matrix}0 &amp; 1 &amp; 0 &amp; 1\\\\1 &amp; 0 &amp; 1 &amp; 1\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\1 &amp; 1 &amp; 0 &amp; 0\\end{matrix}\\right)\\) peut s'implanter en python par le code :</p> Matrice d'adjacence<pre><code>[[0, 1, 0, 1], [1, 0, 1, 1], [0, 1, 0, 0], [1, 1, 0, 0]]\n</code></pre> <p>Aide m\u00e9moire</p> <p>On recopie la matrice ligne par ligne.</p> <p>On peut \u00e9galement utiliser le module numpy qui int\u00e8gre un type array qui facilite certains calculs.</p> <p>Exemple</p> <p>La matrice \\(\\left(\\begin{matrix}0 &amp; 1 &amp; 0 &amp; 1\\\\1 &amp; 0 &amp; 1 &amp; 1\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\1 &amp; 1 &amp; 0 &amp; 0\\end{matrix}\\right)\\) peut s'implanter en python par le code :</p> Matrice d'adjacence<pre><code>import numpy as np\nG = np.array([[0, 1, 0, 1], [1, 0, 1, 1], [0, 1, 0, 0], [1, 1, 0, 0]])\n</code></pre> <p>Propri\u00e9t\u00e9</p> <p>On note \\(A\\) la matrice d'adjacence d'un graphe \\(G = (V, E)\\) donn\u00e9 avec \\(S_1, S_2, \\cdots, S_n\\) les sommets de \\(G\\).  </p> <p>Pour \\(k\\in\\mathbb{N}\\), le coefficient de la ligne \\(i\\) et de la colonne \\(j\\) de la matrice \\(A^k\\) correspond au nombre de chemins de longueur \\(k\\) reliant les sommets \\(S_i\\) et \\(S_j\\).</p> <p>Exemple</p> <p>Reprenons le graphe associ\u00e9 \u00e0 la matrice \\(\\left(\\begin{matrix}0 &amp; 1 &amp; 0 &amp; 1\\\\1 &amp; 0 &amp; 1 &amp; 1\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\1 &amp; 1 &amp; 0 &amp; 0\\end{matrix}\\right)\\) dont une repr\u00e9sentation est donn\u00e9e par :</p> <p> </p> <p>On calcule \\(A^3\\) \u00e0 l'aide de python :</p> Matrice d'adjacence<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; G = np.array([[0, 1, 0, 1], [1, 0, 1, 1], [0, 1, 0, 0], [1, 1, 0, 0]])\n&gt;&gt;&gt; np.dot(G, np.dot(G, G))\narray([[2, 4, 1, 3],\n       [4, 2, 3, 4],\n       [1, 3, 0, 1],\n       [3, 4, 1, 2]])\n</code></pre> <p>Le coefficient de la ligne \\(1\\) colonne \\(1\\) vaut \\(2\\) et correspond au nombre de chemins de longueur \\(3\\) reliant \\(A\\) \u00e0 \\(A\\). Ces chemins sont :</p> \\[     A - B - D - A \\qquad \\textrm{et} \\qquad A - D - B - A \\] <p>Calcul de la puissance d'une matrice</p> <p>La m\u00e9thode <code>dot</code> du module <code>numpy</code> prend deux matrices en argument et r\u00e9alise le produit de ces matrices. Ainsi pour une matrice \\(A\\) donn\u00e9e, on \u00e9crit <code>np.dot(A, A)</code> pour calculer la matrice \\(A^2\\).</p>"},{"location":"#parcours-de-graphe","title":"Parcours de graphe","text":""},{"location":"#parcours-en-profondeur","title":"Parcours en profondeur","text":""},{"location":"#parcours-en-largeur-dabord","title":"Parcours en largeur d'abord","text":""},{"location":"Exercices/","title":"Exercices","text":""},{"location":"Exercices/#les-exercices-de-base","title":"Les exercices de base","text":"<p>Exercice 1</p> <p>On consid\u00e8re le graphe \\(G = (V, E)\\) avec :</p> \\[     V = \\lbrace A, B, C, D, E\\rbrace \\quad \\textrm{et} \\quad E = \\left\\lbrace \\rule[0.5cm]{0cm}{0pt} \\lbrace A, B \\rbrace, \\lbrace A, C\\rbrace, \\lbrace A, E\\rbrace, \\lbrace B, D \\rbrace, \\lbrace C, D \\rbrace\\right\\rbrace \\] <ol> <li>Quel est le degr\u00e9 du sommet \\(A\\) ?</li> <li>Existe-il une cha\u00eene entre \\(A\\) et \\(D\\) ?</li> <li>Repr\u00e9senter ce graphe.</li> </ol> Indications <ol> <li>Il suffit de compter les ar\u00eates contenant \\(A\\).</li> <li>Il suffit de suivre les ar\u00eates en partant de \\(A\\) et voir si l'on arrive sur \\(D\\).</li> </ol> Correction <ol> <li> <p>On compte exactement trois ar\u00eates contenant \\(A\\). D'o\u00f9 \\(\\delta(A) = 3\\).</p> </li> <li> <p>Il existe plusieurs cha\u00eenes possibles :</p> \\[     \\lbrace A, B \\rbrace - \\lbrace B, D \\rbrace \\quad \\textrm{ou} \\quad \\lbrace A, C \\rbrace - \\lbrace C, D \\rbrace   \\] </li> <li> <p>Une possibilit\u00e9 est : </p> <p> </p> </li> </ol> <p>Exercice 2</p> <p>On consid\u00e8re le graphe orient\u00e9 \\(G = (V, E)\\) avec :</p> \\[     V = \\lbrace A, B, C, D, E, F\\rbrace \\quad \\textrm{et} \\quad E = \\left\\lbrace \\rule[0.5cm]{0cm}{0pt} (A, D), (A, E), (B, A), (B, C), (C, F), (D, C), (F, B)\\right\\rbrace \\] <ol> <li>D\u00e9terminer les valeurs de \\(\\delta^-(C)\\) et \\(\\delta^+(C)\\).</li> <li>Combien y-a-t il de cycles partant du sommet \\(C\\) ?</li> <li>Donner une repr\u00e9sentation de ce graphe.</li> </ol> Indications <ol> <li>\\(\\delta^-(C)\\) correspond au nombre d'arcs entrants du sommet \\(C\\). On compte alors les arcs ayant \\(C\\) pour cible.</li> <li>Il suffit de suivre les chemins possibles avec les arcs propos\u00e9s.</li> </ol> Correction <ol> <li>On a \\(\\delta^-(C) = 2\\) car il y a deux arcs avec \\(C\\) comme cible et \\(\\delta^+(C) = 1\\) car un seul arc poss\u00e8de \\(C\\) comme origine.</li> <li> <p>Il y a deux cycles depuis le sommet \\(C\\) donn\u00e9s par les chemins :</p> \\[     (C, F) - (F, B) - (B, C) \\quad \\textrm{et} \\quad (C, F) - (F, B) - (B, A) - (A, D) - (D, C) \\] </li> <li> <p>Une possibilit\u00e9 est : </p> <p> </p> </li> </ol>"},{"location":"Exercices/#avec-une-liste-dadjacence","title":"Avec une liste d'adjacence","text":"<p>Exercice 3</p> <p>On consid\u00e8re le graphe dont la liste d'adjacence est donn\u00e9e par :</p> \\[     \\begin{array}{ccl}         \\begin{array}{|c|}\\hline A\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|}\\hline B \\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline B\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|c|}\\hline A &amp; D &amp; G \\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline C\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|}\\hline D &amp; E \\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline D\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|c|c|}\\hline B &amp; C &amp; E &amp; G\\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline E\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|}\\hline C &amp; D \\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline F\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|}\\hline G\\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline G\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|c|}\\hline B &amp; D &amp; F\\\\\\hline\\end{array}\\\\     \\end{array} \\] <ol> <li>Ce graphe est-il orient\u00e9 ou simple ?</li> <li>Donner le degr\u00e9 du sommet \\(D\\).</li> <li>Proposer un dictionnaire \u00e9crit en python implantant ce graphe.</li> </ol> Indications <ol> <li>Il suffit de v\u00e9rifier si chaque ar\u00eate \\((u, v)\\) poss\u00e8de son sym\u00e9trique \\((v, u)\\) dans la liste d'adjacence.</li> </ol> Correction <ol> <li>Toutes les ar\u00eates poss\u00e8dent un sym\u00e9trique dans la liste donc le graphe est simple.</li> <li>Le sommet de \\(D\\) est \\(\\delta(D) = 4\\).</li> <li> <p>On propose le dictionnaire :</p> Proposition de correction<pre><code>G = {   'A' : ['B'],\n        'B' : ['A', 'D', 'G'],\n        'C' : ['D', 'E'],\n        'D' : ['B', 'C', 'E', 'G'],\n        'E' : ['C', 'D'],\n        'F' : ['G'],\n        'G' : ['B', 'D', 'F']}\n</code></pre> </li> </ol> <p>Exercice 4</p> <ol> <li>\u00c9crire une fonction <code>degre(G : dict, s : str) -&gt; int</code> qui renvoie le degr\u00e9 d'un sommet \\(s\\).</li> <li> <p>Compl\u00e9ter la fonction <code>degre_max(G : dict) -&gt; str</code> qui renvoie le sommet de plus grand degr\u00e9 dans un graphe \\(G\\) :</p> Plus haut degr\u00e9<pre><code>from math import inf\n\ndef degre_max(G : dict) -&gt; str:\n    res  = None\n    maxi = -inf\n\n    for el in G:\n        if ... &gt; ... :\n            res  = ...\n            maxi = ...\n\n    return res\n</code></pre> </li> </ol> Indications <ol> <li>Le degr\u00e9 correspond au nombre de voisins.</li> <li>Lorsqu'on trouve un sommet avec un degr\u00e9 plus grand, on le garde en m\u00e9moire.</li> </ol> Correction <ol> <li> <p>Le degr\u00e9 correspond \u00e0 la longueur de la liste associ\u00e9e :</p> Plus haut degr\u00e9<pre><code>def degre_max(G : dict, s : str) -&gt; int:\n    return len(G[s])\n</code></pre> </li> <li> <p>On propose le code :</p> Plus haut degr\u00e9<pre><code>from math import inf\n\ndef degre_max(G : dict) -&gt; str:\n    res  = None\n    maxi = -inf\n\n    for el in G:\n        if degre(G, el) &gt; maxi :\n            res  = el\n            maxi = degre(G, el)\n\n    return res\n</code></pre> </li> </ol> <p>Exercice 5</p> <p>Pour un graphe orient\u00e9 donn\u00e9 \\(G\\), on appelle inverse de \\(G\\), le graphe \\(\\overline{G}\\) dont tous les arcs ont \u00e9t\u00e9 chang\u00e9s de sens.</p> <p>Par exemple, l'inverse de :</p> <p> </p> <p>est le graphe :</p> <p> </p> <ol> <li>Donner le dictionnaire python associ\u00e9 au graphe \\(G\\) de l'exemple ci-dessus.</li> <li>Donner le dictionnaire python associ\u00e9 au graphe \\(\\overline{G}\\) de l'exemple ci-dessus.</li> <li>\u00c9crire une fonction <code>inverser(g : dict) -&gt; dict</code> qui \u00e0 un dictionnaire donn\u00e9 renvoie le dictionnaire associ\u00e9 au graphe invers\u00e9.</li> </ol> Indications <ol> <li>Facile</li> <li>Facile</li> <li>L'id\u00e9e est d'inverser le dictionnaire associ\u00e9 \u00e0 \\(G\\).</li> </ol> Correction <ol> <li>On a :</li> </ol> Dictionnaire pour G<pre><code>{'C': ['A', 'D', 'F'], 'D': ['B', 'E', 'G']}\n</code></pre> <ol> <li>On a :</li> </ol> Dictionnaire pour G<pre><code>{'A': ['C'], 'B': ['D'], 'D': ['C'], 'E': ['D'], 'F': ['C'], 'G': ['D']}\n</code></pre> <ol> <li>On propose :</li> </ol> Dictionnaire pour l'inverse de G<pre><code>def inverser(g : dict) -&gt; dict:\n    res = {}\n\n    for el in g:\n        for s in g[el]:\n            if not s in res:\n                res[s] = [el]\n            else:\n                res[s].append(el)\n\n    return res\n</code></pre>"},{"location":"Exercices/#avec-une-matrice-dadjacence","title":"Avec une matrice d'adjacence","text":"<p>Exercice 6</p> <p>On consid\u00e8re le graphe \\(G = (V, E)\\) dont une repr\u00e9sentation est donn\u00e9e par</p> <p> </p> <ol> <li>\u00c9crire la matrice d'adjacence associ\u00e9e \u00e0 ce graphe.</li> <li>Proposer une instruction python permettant d'implanter cette matrice d'adjacence.</li> </ol> <p>Exercice 7</p> <p>On consid\u00e8re le graphe \\(G = (V, E)\\) dont la liste d'adjacence est donn\u00e9e par :</p> \\[     \\begin{array}{ccl}         \\begin{array}{|c|}\\hline A\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|}\\hline D \\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline B\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|}\\hline D &amp; F \\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline C\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|c|}\\hline E &amp; F \\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline D\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|}\\hline C\\\\\\hline\\end{array}\\\\         \\begin{array}{|c|}\\hline E\\\\\\hline\\end{array} &amp; \\longrightarrow &amp; \\begin{array}{|c|}\\hline D \\\\\\hline\\end{array}     \\end{array} \\] <ol> <li>\u00c9crire la matrice d'adjacence de ce graphe.</li> <li>Proposer une repr\u00e9sentation de \\(G\\).</li> </ol> <p>Exercice 8</p> <p>On s'int\u00e9resse dans cet exercice au passage d'une matrice d'adjacence \u00e0 une liste d'adjacence.  </p> <p>On consid\u00e8re le graphe orient\u00e9 \\(G = (V, E)\\) dont la matrice d'adjacence est donn\u00e9e par la liste python :</p> <p>Matrice d'adjacence<pre><code>g = [[0, 1, 0, 1, 1], [0, 0, 0, 1, 0], [0, 0, 1, 1, 0], [0, 0, 0, 1, 1], [0, 1, 1, 0, 0]]\n</code></pre> 1. En supposant que les sommets sont nomm\u00e9s \\(A, B, C, D\\) et \\(E\\), donner la liste d'adjacence de ce graphe. 2. Proposer une fonction python <code>matrix_to_list(g : list) -&gt; dict</code> qui renvoie la liste d'adjacence d'un graphe pass\u00e9 en param\u00e8tre via sa matrice d'adjacence.  </p> <p>Par exemple, l'instruction <code>matrix_to_list(g)</code> renverrait :</p> Exemple<pre><code>{'A': ['B', 'D', 'E'], 'B': ['D'], 'C': ['C', 'D'], 'D': ['D', 'E'], 'E': ['B', 'C']}\n</code></pre> <p>Exercice 9</p> <p>On consid\u00e8re un graphe \\(G = (V, E)\\) dont la matrice d'adjacence est donn\u00e9e par la liste python :</p> Matrice d'adjacence<pre><code>g = [[0, 1, 0, 1, 1, 0], [1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0], [0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 0, 0], [1, 0, 0, 1, 1, 0]]\n</code></pre> <ol> <li> <p>Compl\u00e9ter le tableau suivant :</p> \\[     \\begin{array}{|l|c|c|c|c|c|c|}         \\hline         \\textrm{Sommet} &amp; A &amp; B &amp; C &amp; D &amp; E &amp; F\\\\         \\hline         \\textrm{Degr\u00e9 entrant } \\delta^- &amp; &amp; &amp; &amp; &amp; &amp; \\\\         \\hline         \\textrm{Degr\u00e9 sortant } \\delta^+ &amp; &amp; &amp; &amp; &amp; &amp; \\\\         \\hline     \\end{array}     \\] </li> <li> <p>\u00c9crire une fonction python <code>degres(g : list) -&gt; dict</code> qui renvoie le degr\u00e9 entrant et sortant de tous les sommets du graphe. Par exemple pour le graphe </p> <p> </p> <p>on aurait </p> Exemple<pre><code>&gt;&gt;&gt; degres(g)\n{'A': {'in': 0, 'out': 1}, 'B': {'in': 0, 'out': 2}, 'C': {'in': 1, 'out': 2}, 'D': {'in': 3, 'out': 1}, 'E': {'in': 1, 'out': 1}, 'F': {'in': 2, 'out': 0}}\n</code></pre> </li> </ol> <p>Exercice 10</p> <p>On consid\u00e8re le graphe \\(G = (V, E)\\) dont une repr\u00e9sentation est :</p> <p> </p> <ol> <li>\u00c9crire l'instruction permettant d'implanter ce graphe \u00e0 l'aide d'une structure <code>array</code> du module <code>numpy</code> et de l'associer \u00e0 la variable <code>g</code>.</li> <li>\u00c9crire une fonction <code>power(t:array, n:int) -&gt; array</code> qui calcule la puissance \\(n\\)-i\u00e8me de la matrice <code>t</code> pass\u00e9e en param\u00e8tre.</li> <li>L'instruction <code>power(g, 4)</code> a renvoy\u00e9 :     Puissance quatri\u00e8me<pre><code>array([ [31, 22, 13, 26, 21, 13, 21],\n        [22, 31, 13, 26, 21, 13, 21],\n        [13, 13, 11, 17, 11,  6,  7],\n        [26, 26, 17, 34, 18, 17, 18],\n        [21, 21, 11, 18, 20,  7, 15],\n        [13, 13,  6, 17,  7, 11, 11],\n        [21, 21,  7, 18, 15, 11, 20]])\n</code></pre>     Donner les chemins de longueur 4 reliant \\(C\\) \u00e0 \\(F\\).</li> </ol>"},{"location":"Travaux%20pratiques/","title":"Travaux pratiques","text":"<p>On s'int\u00e9resse dans ce TP aux graphes simples non orient\u00e9s.</p>"},{"location":"Travaux%20pratiques/#implantation-par-une-classe","title":"Implantation par une classe","text":"<p>On propose d'implanter les graphes \u00e0 l'aide d'une classe dont le corps principal est donn\u00e9 par le code suivant :</p> D\u00e9but d'implantation de GrapheSimple<pre><code>    from graphviz import Graph\n\n    class GrapheSimple:\n\n        def __init__(self, vertices:list):\n            self.vertices = vertices\n            self.edges    = {}\n\n        def add_edge(self, start:str, end:str):\n            pass\n\n        def add_edges(self, edges : list):\n            pass\n\n        def show(self):\n            dot = Graph(format='pdf', node_attr={'shape':'circle'})\n\n            for s in self.edges:\n                for e in self.edges[s]:\n                    dot.edge(s, e)\n\n            dot.view()\n</code></pre> <p>On utilise le concept de liste d'adjacence pour implanter les graphes.</p> <p>Pour commencer</p> <ol> <li> <p>La m\u00e9thode <code>add_edge(start:str, end:str) -&gt; None</code> permet d'ajouter une ar\u00eate \u00e0 deux sommets existants pass\u00e9s en param\u00e8tre.     Compl\u00e9ter le code de cette m\u00e9thode.</p> <p>Utilisation de la m\u00e9thode <code>add_edge</code></p> <p>On poss\u00e8de le graphe \\(G\\) donn\u00e9 par <code>G = GrapheSimple(['A', 'B', 'C', 'D'])</code>. Pour cr\u00e9er l'ar\u00eate \\(\\lbrace A, B\\rbrace\\), on utilise l'instruction <code>G.add_edge('A', 'B')</code>.</p> </li> <li> <p>La m\u00e9thode <code>add_edges(edges:list) -&gt; None</code> permet d'ajouter toute une liste d'ar\u00eates pass\u00e9e en param\u00e8tre.     Compl\u00e9ter le code de cette m\u00e9thode.</p> <p>Utilisation de la m\u00e9thode <code>add_edges</code></p> <p>On poss\u00e8de le graphe \\(G\\) donn\u00e9 par <code>G = GrapheSimple(['A', 'B', 'C', 'D'])</code>. Pour cr\u00e9er les ar\u00eates \\(\\lbrace A, B\\rbrace\\), \\(\\lbrace A, C\\rbrace\\) et \\(\\lbrace B, D\\rbrace\\), on utilise l'instruction <code>G.add_edges([('A', 'B'), ('A', 'C'), ('B', 'D')])</code></p> </li> </ol> Indications <ol> <li>Il ne faut pas oublier de cr\u00e9er aussi l'ar\u00eate r\u00e9ciproque.</li> <li>Utiliser la m\u00e9thode <code>add_edge</code> dans une boucle.</li> </ol> Correction <ol> <li> <p>On ajoute l'ar\u00eate \u00e0 la liste si elle existe d\u00e9j\u00e0. Sinon on cr\u00e9e la liste.</p> M\u00e9thode `add_edge`<pre><code>def add_edge(self, start, end):\n    # Ar\u00eate principale\n    if start in self.edges:\n        self.edges[start].append(end)\n    else:\n        self.edges[start] = [end]\n    #\u00a0Ar\u00eate r\u00e9ciproque\n    if end in self.edges:\n        self.edges[end].append(start)\n    else:\n        self.edges[end] = [start]\n</code></pre> </li> <li> <p>On propose le code :</p> M\u00e9thode `add_edge`<pre><code>def add_edges(self, edges):\n    for el in edges:\n        self.add_edge(el[0], el[1])\n</code></pre> </li> </ol> <p>On se propose d'implanter en Python le graphe ci-dessous :</p> <p> </p> <p>Implantation du graphe</p> <ol> <li>Proposer deux instructions permettant d'implanter le graphe ci-dessus et de l'associer \u00e0 la variable <code>G</code>.</li> <li>V\u00e9rifier que l'instruction <code>G.show()</code> affiche un graphe pas tr\u00e8s joli.</li> <li>Corriger la m\u00e9thode <code>show</code> pour qu'elle ne trace pas des ar\u00eates d\u00e9j\u00e0 trac\u00e9es.</li> </ol> Indications <ol> <li>Utiliser le constructeur <code>G = GrapheSimple([...])</code> puis l'instruction <code>G.add_edges([...])</code>.</li> <li>Cette m\u00e9thode trace deux ar\u00eates \u00e0 la place d'une seule.</li> <li>Tester si l'ar\u00eate \u00e0 tracer a d\u00e9j\u00e0 \u00e9t\u00e9 trac\u00e9e.</li> </ol> Correction <ol> <li> <p>On utilise le code :</p> Construction d'un graphe simple<pre><code>G = GrapheSimple(['A', 'B', 'C', 'D', 'E', 'F', 'G'])\nG.add_edges([('A', 'B'), ('A', 'C'), ('B', 'C'), ('B', 'F'), ('C', 'E'), ('C', 'F'), ('C', 'G'), ('D', 'E'), ('D', 'G'), ('E', 'G'), ('F', 'G')])\n</code></pre> </li> <li> <p>Rien \u00e0 faire.</p> </li> <li> <p>Il faut int\u00e9grer une variable <code>tracees</code> qui contient les ar\u00eates d\u00e9j\u00e0 trac\u00e9es.</p> Repr\u00e9sentation d'un graphe<pre><code>def show(self):\n    dot = Graph(format='pdf', node_attr={'shape':'circle'})\n    tracees = []\n\n    for s in self.edges:\n        for e in self.edges[s]:\n            if not (e, s) in tracees:\n                tracees.append((s, e))\n                dot.edge(s, e)\n\n    dot.view()\n</code></pre> <p>Pour plus de beaut\u00e9</p> <p>On peut modifier les attributs du graphe pour que celui-ci s'affiche plut\u00f4t horizontalement en modifiant la ligne 2 par :</p> Plus joli<pre><code>dot = Graph(format='pdf', node_attr={'shape':'circle'}, graph_attr={'rankdir':'LR'})\n</code></pre> </li> </ol>"},{"location":"Travaux%20pratiques/#implantation-des-parcours","title":"Implantation des parcours","text":""},{"location":"Travaux%20pratiques/#parcours-en-largeur-dabord","title":"Parcours en largeur d'abord","text":"<p>L'algorithme de parcours en largeur d'abord (ou BFS, pour Breadth-First Search en anglais) permet le parcours d'un graphe de la mani\u00e8re suivante : on commence par explorer un n\u0153ud source, puis ses successeurs, puis les successeurs non explor\u00e9s des successeurs, etc.  </p> <p>Le parcours en largeur d'abord utilise une file dans laquelle il va stocker les sommets adjacents non encore explor\u00e9s. Il est donc important de marquer les sommets visit\u00e9s pour \u00e9viter d'y retourner et de boucler ind\u00e9finiment.</p> <p>Retour sur les files</p> <p>On propose la structure suivante pour l'implantation d'une file :</p> Structure de file<pre><code>def creer_file():\n    return []\n\ndef file_vide(f):\n    pass\n\ndef enfiler(f, val):\n    pass\n\ndef defiler(f):\n    pass\n</code></pre> <ol> <li>Compl\u00e9ter les diff\u00e9rentes m\u00e9thodes pour qu'elles soient fonctionnelles.</li> </ol> Indications <ol> <li>G\u00e9n\u00e9ralement, on enfile au d\u00e9but de la liste avec la m\u00e9thode <code>insert</code> et on d\u00e9file avec la m\u00e9thode <code>pop</code>.</li> </ol> Correction <ol> <li> <p>On propose le code suivant :</p> Gestion d'une file<pre><code>def creer_file():\n    return []\n\ndef file_vide(f):\n    return len(f) == 0\n\ndef enfiler(f, val):\n    f.insert(0, val)\n\ndef defiler(f):\n    if not file_vide(f):\n        res = f.pop()\n    else:\n        res = None\n    return res\n</code></pre> </li> </ol> <p>Pour marquer les sommets visit\u00e9s, on peut utiliser une liste simple dans laquelle on ajoute leur nom. Ainsi, avant d'enfiler les voisins, on v\u00e9rifie qu'ils n'ont pas d\u00e9j\u00e0 \u00e9t\u00e9 visit\u00e9s.</p> <p>Parcours en largeur</p> <ol> <li>Implanter la m\u00e9thode <code>breadth_first_search(start:str) -&gt; list</code> qui renvoie la liste des sommets visit\u00e9s depuis la source <code>start</code> en utilisant un parcours en largeur d'abord.</li> </ol> Indications <ol> <li> <p>On pourra compl\u00e9ter le code suivant :</p> M\u00e9thode BFS<pre><code>def breadth_first_search(self, start):\n    res = []\n\n    f = creer_file()\n    visites = {v : False for v in self.vertices}\n\n    enfiler(f, start)\n    ... = True # Le sommet de d\u00e9part est marqu\u00e9\n\n    while not file_vide(f):\n        x = defiler(f)\n        res.append(x)\n\n        for el in self.edges[x]:\n            if ........ : # si le voisin n'est pas marqu\u00e9\n                enfiler(f, ...) #\u00a0enfiler le voisin\n                visites[el] = ... # marquer le voisin\n\n    return res\n</code></pre> </li> </ol> Correction <ol> <li> <p>On propose le code :</p> M\u00e9thode BFS<pre><code>def breadth_first_search(self, start):\n    res = []\n\n    f = creer_file()\n    visites = {v : False for v in self.vertices}\n\n    enfiler(f, start)\n    visites[start] = True\n\n    while not file_vide(f):\n        x = defiler(f)\n        res.append(x)\n\n        for el in self.edges[x]:\n            if not visites[el]:\n                enfiler(f, el)\n                visites[el] = True\n\n    return res\n</code></pre> </li> </ol>"},{"location":"Travaux%20pratiques/#parcours-en-profondeur","title":"Parcours en profondeur","text":"<p>L'algorithme de parcours en profondeur (ou parcours en profondeur, ou DFS, pour Depth-First Search) est un algorithme de parcours de graphe. Il se d\u00e9crit naturellement de mani\u00e8re r\u00e9cursive.</p> <p>On poursuit un chemin dans le graphe jusqu'\u00e0 un cul-de-sac ou alors jusqu'\u00e0 atteindre un sommet d\u00e9j\u00e0 visit\u00e9. On revient alors sur le dernier sommet o\u00f9 on pouvait suivre un autre chemin puis on explore un autre chemin. L'exploration s'arr\u00eate quand tous les sommets depuis \\(S\\) ont \u00e9t\u00e9 visit\u00e9s.  </p> <p>Il est possible d'impl\u00e9menter le parcours en profondeur it\u00e9rativement \u00e0 l'aide d'une pile LIFO contenant les sommets \u00e0 explorer : on d\u00e9sempile un sommet et on empile ses voisins non encore explor\u00e9s.</p> <p>Parcours en profondeur</p> <ol> <li>Proposer un code complet permettant d'utiliser une pile.</li> <li>Implanter la m\u00e9thode <code>depth_first_search(start:str) -&gt; list</code> qui renvoie la liste des sommets visit\u00e9s depuis la source <code>start</code> en utilisant un parcours en prodondeur.</li> </ol> Indications <ol> <li>Pour une pile, on empile g\u00e9n\u00e9ralement \u00e0 l'aide de la m\u00e9thode <code>append</code> et on d\u00e9pile \u00e0 l'aide de <code>pop</code>.</li> <li>On calque le parcours en largeur d'abord.</li> </ol> Correction <ol> <li> <p>On propose le code suivant :</p> M\u00e9thode DFS<pre><code>res = []\n\np = creer_pile()\nvisites = {v : False for v in self.vertices}\n\nempiler(p, start)\nvisites[start] = True\n\nwhile not pile_vide(p):\n    x = depiler(p)\n    res.append(x)\n\n    for el in self.edges[x]:\n        if not visites[el]:\n            empiler(p, el)\n            visites[el] = True\n\nreturn res\n</code></pre> </li> </ol>"},{"location":"Travaux%20pratiques/#applications","title":"Applications","text":"<p>I'm tired.</p>"}]}